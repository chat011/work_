import re
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
import json
import os
from datetime import datetime
from PIL import Image
import requests
from io import BytesIO
import asyncio
import aiohttp
import concurrent.futures
from typing import List, Dict, Tuple, Optional
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

DEFAULT_IMAGE_SIZE = {"width": 800, "height": 800}

class EnhancedImageURLFixer:
    """Enhanced image URL fixer with async processing and better validation"""
    
    def __init__(self, max_concurrent_requests: int = 10, timeout: int = 10):
        self.max_concurrent_requests = max_concurrent_requests
        self.timeout = timeout
        self.session = None
    
    async def __aenter__(self):
        """Async context manager entry"""
        self.session = aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=self.timeout),
            connector=aiohttp.TCPConnector(limit=self.max_concurrent_requests)
        )
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""
        if self.session:
            await self.session.close()

    def fix_image_url(self, url: str) -> str:
        """
        Fix image URLs by removing placeholder parameters that make them 1x1 pixels
        Enhanced version with better URL parsing and validation
        """
        if not url or not isinstance(url, str):
            return url
        
        # Skip data URLs (base64 encoded images)
        if url.startswith('data:'):
            return url if not self.is_transparent_placeholder(url) else ""
        
        try:
            # Parse the URL
            parsed = urlparse(url)
            
            # Parse query parameters
            params = parse_qs(parsed.query, keep_blank_values=False)
            
            # Remove problematic parameters that create placeholder images
            problematic_params = ['width', 'height', 'crop', 'c', 'w', 'h']
            
            # Check if this is a 1x1 placeholder image
            is_placeholder = self._is_placeholder_image(params, url)
            
            if is_placeholder:
                # Keep only useful parameters
                useful_params = {}
                keep_params = ['v', 'version', 'quality', 'format', 'q', 'f']
                
                for param, values in params.items():
                    if param in keep_params and values:
                        useful_params[param] = values
                
                # Rebuild the URL without placeholder parameters
                new_query = urlencode(useful_params, doseq=True)
                fixed_url = urlunparse((
                    parsed.scheme,
                    parsed.netloc,
                    parsed.path,
                    parsed.params,
                    new_query,
                    parsed.fragment
                ))
                
                return fixed_url
            
            return url
            
        except Exception as e:
            logger.warning(f"Error fixing URL {url}: {e}")
            return url

    def _is_placeholder_image(self, params: Dict, url: str) -> bool:
        """Enhanced placeholder detection"""
        # Method 1: Check for 1x1 dimensions in parameters
        width_vals = params.get('width', []) + params.get('w', [])
        height_vals = params.get('height', []) + params.get('h', [])
        
        has_1x1_params = (
            any(val == '1' for val in width_vals) or
            any(val == '1' for val in height_vals)
        )
        
        # Method 2: Check for 1x1 in URL string
        has_1x1_in_url = 'width=1' in url or 'height=1' in url or 'w=1' in url or 'h=1' in url
        
        # Method 3: Check for common placeholder patterns
        placeholder_patterns = [
            r'[?&]w=1[&$]',
            r'[?&]h=1[&$]',
            r'[?&]width=1[&$]',
            r'[?&]height=1[&$]',
            r'[?&]crop=center.*[?&](?:width|w)=1',
            r'[?&]crop=center.*[?&](?:height|h)=1'
        ]
        
        has_placeholder_pattern = any(re.search(pattern, url) for pattern in placeholder_patterns)
        
        return has_1x1_params or has_1x1_in_url or has_placeholder_pattern

    async def get_image_size_async(self, url: str) -> Dict[str, int]:
        """Get image size asynchronously with better error handling"""
        try:
            if not self.session:
                raise ValueError("Session not initialized. Use async context manager.")
            
            # Add headers to mimic a browser request
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8',
                'Accept-Encoding': 'gzip, deflate, br',
                'Accept-Language': 'en-US,en;q=0.9',
                'Cache-Control': 'no-cache',
                'Pragma': 'no-cache'
            }
            
            async with self.session.get(url, headers=headers) as response:
                if response.status == 200:
                    # Read only the first chunk to get dimensions
                    chunk_size = 2048  # Read first 2KB for image header
                    content = await response.content